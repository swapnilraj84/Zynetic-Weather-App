"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorCode = void 0;
exports.addGravatarSupport = addGravatarSupport;
exports.addScope = addScope;
Object.defineProperty(exports, "buildToken", {
  enumerable: true,
  get: function () {
    return _utils.buildToken;
  }
});
exports.convertPayloadToBase64 = convertPayloadToBase64;
exports.deleteProperties = deleteProperties;
exports.encodeScopedUri = encodeScopedUri;
exports.fileExists = fileExists;
exports.folderExists = folderExists;
exports.formatAuthor = formatAuthor;
exports.getVersion = getVersion;
exports.hasDiffOneKey = hasDiffOneKey;
exports.hasLogin = hasLogin;
exports.isHost = isHost;
exports.isObject = void 0;
exports.isObjectOrArray = isObjectOrArray;
exports.isRelatedToDeprecation = isRelatedToDeprecation;
exports.isVersionValid = isVersionValid;
exports.mask = mask;
exports.normalizeDistTags = normalizeDistTags;
exports.pad = pad;
exports.parseAddress = parseAddress;
exports.parseConfigFile = parseConfigFile;
exports.parseInterval = parseInterval;
exports.parseReadme = parseReadme;
exports.semverSort = semverSort;
exports.sortByName = sortByName;
exports.tagVersion = tagVersion;
exports.validateURL = validateURL;
var _debug = _interopRequireDefault(require("debug"));
var _fs = _interopRequireDefault(require("fs"));
var _jsYaml = _interopRequireDefault(require("js-yaml"));
var _lodash = _interopRequireDefault(require("lodash"));
var _semver = _interopRequireDefault(require("semver"));
var _url = require("url");
var _validator = _interopRequireDefault(require("validator"));
var _core = require("@verdaccio/core");
var _utils = require("@verdaccio/utils");
var _constants = require("./constants");
var _logger = require("./logger");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const {
  getBadData,
  getBadRequest,
  getCode,
  getConflict,
  getForbidden,
  getInternalError,
  getNotFound,
  getServiceUnavailable,
  getUnauthorized
} = _core.errorUtils;
const debug = (0, _debug.default)('verdaccio');
const validProtocols = ['https', 'http'];
function convertPayloadToBase64(payload) {
  return Buffer.from(payload, 'base64');
}

/**
 * Check whether an element is an Object
 * @param {*} obj the element
 * @return {Boolean}
 */
const isObject = _core.validatioUtils.isObject;

/**
 * @deprecated not used un v6
 */
exports.isObject = isObject;
function isObjectOrArray(obj) {
  return _lodash.default.isObject(obj) && _lodash.default.isNull(obj) === false;
}
function tagVersion(data, version, tag) {
  if (tag && data[_constants.DIST_TAGS][tag] !== version && _semver.default.parse(version, true)) {
    // valid version - store
    data[_constants.DIST_TAGS][tag] = version;
    return true;
  }
  return false;
}

/**
 * Gets version from a package object taking into account semver weirdness.
 * @return {String} return the semantic version of a package
 */
function getVersion(pkg, version) {
  // this condition must allow cast
  if (_lodash.default.isNil(pkg.versions[version]) === false) {
    return pkg.versions[version];
  }
  try {
    version = _semver.default.parse(version, true);
    for (const versionItem in pkg.versions) {
      if (version.compare(_semver.default.parse(versionItem, true)) === 0) {
        return pkg.versions[versionItem];
      }
    }
  } catch (err) {
    return undefined;
  }
}

/**
 * Parse an internet address
 * Allow:
 - https:localhost:1234        - protocol + host + port
 - localhost:1234              - host + port
 - 1234                        - port
 - http::1234                  - protocol + port
 - https://localhost:443/      - full url + https
 - http://[::1]:443/           - ipv6
 - unix:/tmp/http.sock         - unix sockets
 - https://unix:/tmp/http.sock - unix sockets (https)
 * @param {*} urlAddress the internet address definition
 * @return {Object|Null} literal object that represent the address parsed
 */
function parseAddress(urlAddress) {
  //
  // TODO: refactor it to something more reasonable?
  //
  //        protocol :  //      (  host  )|(    ipv6     ):  port  /
  let urlPattern = /^((https?):(\/\/)?)?((([^\/:]*)|\[([^\[\]]+)\]):)?(\d+)\/?$/.exec(urlAddress);
  if (urlPattern) {
    return {
      proto: urlPattern[2] || _constants.DEFAULT_PROTOCOL,
      host: urlPattern[6] || urlPattern[7] || _constants.DEFAULT_DOMAIN,
      port: urlPattern[8] || _constants.DEFAULT_PORT
    };
  }
  urlPattern = /^((https?):(\/\/)?)?unix:(.*)$/.exec(urlAddress);
  if (urlPattern) {
    return {
      proto: urlPattern[2] || _constants.DEFAULT_PROTOCOL,
      path: urlPattern[4]
    };
  }
  return null;
}

/**
 * Function filters out bad semver versions and sorts the array.
 * @return {Array} sorted Array
 */
function semverSort(listVersions) {
  return listVersions.filter(function (x) {
    if (!_semver.default.parse(x, true)) {
      _logger.logger.warn({
        ver: x
      }, 'ignoring bad version @{ver}');
      return false;
    }
    return true;
  })
  // FIXME: it seems the @types/semver do not handle a legitimate method named 'compareLoose'
  // @ts-ignore
  .sort(_semver.default.compareLoose).map(String);
}

/**
 * Flatten arrays of tags.
 * @param {*} data
 */
function normalizeDistTags(pkg) {
  let sorted;
  if (!pkg[_constants.DIST_TAGS].latest) {
    // overwrite latest with highest known version based on semver sort
    sorted = semverSort(Object.keys(pkg.versions));
    if (sorted && sorted.length) {
      pkg[_constants.DIST_TAGS].latest = sorted.pop();
    }
  }
  for (const tag in pkg[_constants.DIST_TAGS]) {
    if (_lodash.default.isArray(pkg[_constants.DIST_TAGS][tag])) {
      if (pkg[_constants.DIST_TAGS][tag].length) {
        // sort array
        // FIXME: this is clearly wrong, we need to research why this is like this.
        // @ts-ignore
        sorted = semverSort(pkg[_constants.DIST_TAGS][tag]);
        if (sorted.length) {
          // use highest version based on semver sort
          pkg[_constants.DIST_TAGS][tag] = sorted.pop();
        }
      } else {
        delete pkg[_constants.DIST_TAGS][tag];
      }
    } else if (_lodash.default.isString(pkg[_constants.DIST_TAGS][tag])) {
      if (!_semver.default.parse(pkg[_constants.DIST_TAGS][tag], true)) {
        // if the version is invalid, delete the dist-tag entry
        delete pkg[_constants.DIST_TAGS][tag];
      }
    }
  }
}
const parseIntervalTable = {
  '': 1000,
  ms: 1,
  s: 1000,
  m: 60 * 1000,
  h: 60 * 60 * 1000,
  d: 86400000,
  w: 7 * 86400000,
  M: 30 * 86400000,
  y: 365 * 86400000
};

/**
 * Parse an internal string to number
 * @param {*} interval
 * @return {Number}
 */
function parseInterval(interval) {
  if (typeof interval === 'number') {
    return interval * 1000;
  }
  let result = 0;
  let last_suffix = Infinity;
  interval.split(/\s+/).forEach(function (x) {
    if (!x) {
      return;
    }
    const m = x.match(/^((0|[1-9][0-9]*)(\.[0-9]+)?)(ms|s|m|h|d|w|M|y|)$/);
    if (!m || parseIntervalTable[m[4]] >= last_suffix || m[4] === '' && last_suffix !== Infinity) {
      throw Error('invalid interval: ' + interval);
    }
    last_suffix = parseIntervalTable[m[4]];
    result += Number(m[1]) * parseIntervalTable[m[4]];
  });
  return result;
}
const ErrorCode = {
  getConflict,
  getBadData,
  getBadRequest,
  getInternalError,
  getUnauthorized,
  getForbidden,
  getServiceUnavailable,
  getNotFound,
  getCode
};
exports.ErrorCode = ErrorCode;
function parseConfigFile(configPath) {
  try {
    if (/\.ya?ml$/i.test(configPath)) {
      return _jsYaml.default.load(_fs.default.readFileSync(configPath, 'utf-8'));
    }
    debug('yaml parsed');
    return require(configPath);
  } catch (e) {
    debug('yaml parse failed');
    if (e.code !== 'MODULE_NOT_FOUND') {
      e.message = _constants.APP_ERROR.CONFIG_NOT_VALID;
    }
    throw new Error(e);
  }
}

/**
 * Check whether the path already exist.
 * @param {String} path
 * @return {Boolean}
 */
function folderExists(path) {
  try {
    const stat = _fs.default.statSync(path);
    return stat.isDirectory();
  } catch (_) {
    return false;
  }
}

/**
 * Check whether the file already exist.
 * @param {String} path
 * @return {Boolean}
 */
function fileExists(path) {
  try {
    const stat = _fs.default.statSync(path);
    return stat.isFile();
  } catch (_) {
    return false;
  }
}
function sortByName(packages, orderAscending = true) {
  return packages.slice().sort(function (a, b) {
    const comparatorNames = a.name.toLowerCase() < b.name.toLowerCase();
    return orderAscending ? comparatorNames ? -1 : 1 : comparatorNames ? 1 : -1;
  });
}
function addScope(scope, packageName) {
  return `@${scope}/${packageName}`;
}
function deleteProperties(propertiesToDelete, objectItem) {
  _lodash.default.forEach(propertiesToDelete, property => {
    delete objectItem[property];
  });
  return objectItem;
}
function addGravatarSupport(pkgInfo, online = true) {
  const pkgInfoCopy = _objectSpread({}, pkgInfo);
  const author = _lodash.default.get(pkgInfo, 'latest.author', null);
  const contributors = (0, _utils.normalizeContributors)(_lodash.default.get(pkgInfo, 'latest.contributors', []));
  const maintainers = _lodash.default.get(pkgInfo, 'latest.maintainers', []);

  // for author.
  if (author && _lodash.default.isObject(author)) {
    const {
      email
    } = author;
    pkgInfoCopy.latest.author.avatar = (0, _utils.generateGravatarUrl)(email, online);
  }
  if (author && _lodash.default.isString(author)) {
    pkgInfoCopy.latest.author = {
      avatar: _utils.GENERIC_AVATAR,
      email: '',
      author
    };
  }

  // for contributors
  if (_lodash.default.isEmpty(contributors) === false) {
    pkgInfoCopy.latest.contributors = contributors.map(contributor => {
      if (isObject(contributor)) {
        contributor.avatar = (0, _utils.generateGravatarUrl)(contributor.email, online);
      } else if (_lodash.default.isString(contributor)) {
        contributor = {
          avatar: _utils.GENERIC_AVATAR,
          email: contributor,
          name: contributor
        };
      }
      return contributor;
    });
  }

  // for maintainers
  if (_lodash.default.isEmpty(maintainers) === false) {
    pkgInfoCopy.latest.maintainers = maintainers.map(maintainer => {
      maintainer.avatar = (0, _utils.generateGravatarUrl)(maintainer.email, online);
      return maintainer;
    });
  }
  return pkgInfoCopy;
}

/**
 * parse package readme - markdown/ascii
 * @param {String} packageName name of package
 * @param {String} readme package readme

 * @return {String} converted html template
 */
function parseReadme(packageName, readme) {
  if (_lodash.default.isEmpty(readme) === false) {
    return readme;
  }

  // logs readme not found error
  _logger.logger.info({
    packageName
  }, '@{packageName}: No readme found');
  return 'ERROR: No README data found!';
}
/**
 * Formats author field for webui.
 * @see https://docs.npmjs.com/files/package.json#author
 * @param {string|object|undefined} author
 */
function formatAuthor(author) {
  let authorDetails = {
    name: _constants.DEFAULT_USER,
    email: '',
    url: ''
  };
  if (_lodash.default.isNil(author)) {
    return authorDetails;
  }
  if (_lodash.default.isString(author)) {
    authorDetails = _objectSpread(_objectSpread({}, authorDetails), {}, {
      name: author
    });
  }
  if (_lodash.default.isObject(author)) {
    authorDetails = _objectSpread(_objectSpread({}, authorDetails), author);
  }
  return authorDetails;
}

/**
 * Apply whitespaces based on the length
 * @param {*} str the log message
 * @return {String}
 */
function pad(str, max) {
  if (str.length < max) {
    return str + ' '.repeat(max - str.length);
  }
  return str;
}

/**
 * return a masquerade string with its first and last {charNum} and three dots in between.
 * @param {String} str
 * @param {Number} charNum
 * @returns {String}
 */
function mask(str, charNum = 3) {
  return `${str.substr(0, charNum)}...${str.substr(-charNum)}`;
}
function encodeScopedUri(packageName) {
  return packageName.replace(/\//g, '%2f');
}
function hasDiffOneKey(versions) {
  return Object.keys(versions).length !== 1;
}
function isVersionValid(packageMeta, packageVersion) {
  const hasVersion = typeof packageVersion !== 'undefined';
  if (!hasVersion) {
    return false;
  }
  const hasMatchVersion = Object.keys(packageMeta.versions).includes(packageVersion);
  return hasMatchVersion;
}
function isRelatedToDeprecation(pkgInfo) {
  const {
    versions
  } = pkgInfo;
  for (const version in versions) {
    if (Object.prototype.hasOwnProperty.call(versions[version], 'deprecated')) {
      return true;
    }
  }
  return false;
}
function validateURL(publicUrl) {
  try {
    const parsed = new _url.URL(publicUrl);
    if (!validProtocols.includes(parsed.protocol.replace(':', ''))) {
      throw Error('invalid protocol');
    }
    return true;
  } catch (err) {
    // TODO: add error logger here
    return false;
  }
}
function isHost(url = '', options = {}) {
  return _validator.default.isURL(url, _objectSpread({
    require_host: true,
    allow_trailing_dot: false,
    require_valid_protocol: false,
    // @ts-ignore
    require_port: false,
    require_tld: false
  }, options));
}
function hasLogin(config) {
  var _config$web, _config$web2;
  // FIXME: types are not yet on the library verdaccio/monorepo
  // @ts-ignore
  return _lodash.default.isNil(config === null || config === void 0 ? void 0 : (_config$web = config.web) === null || _config$web === void 0 ? void 0 : _config$web.login) || (config === null || config === void 0 ? void 0 : (_config$web2 = config.web) === null || _config$web2 === void 0 ? void 0 : _config$web2.login) === true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRCYWREYXRhIiwiZ2V0QmFkUmVxdWVzdCIsImdldENvZGUiLCJnZXRDb25mbGljdCIsImdldEZvcmJpZGRlbiIsImdldEludGVybmFsRXJyb3IiLCJnZXROb3RGb3VuZCIsImdldFNlcnZpY2VVbmF2YWlsYWJsZSIsImdldFVuYXV0aG9yaXplZCIsImVycm9yVXRpbHMiLCJkZWJ1ZyIsImJ1aWxkRGVidWciLCJ2YWxpZFByb3RvY29scyIsImNvbnZlcnRQYXlsb2FkVG9CYXNlNjQiLCJwYXlsb2FkIiwiQnVmZmVyIiwiZnJvbSIsImlzT2JqZWN0IiwidmFsaWRhdGlvVXRpbHMiLCJpc09iamVjdE9yQXJyYXkiLCJvYmoiLCJfIiwiaXNOdWxsIiwidGFnVmVyc2lvbiIsImRhdGEiLCJ2ZXJzaW9uIiwidGFnIiwiRElTVF9UQUdTIiwic2VtdmVyIiwicGFyc2UiLCJnZXRWZXJzaW9uIiwicGtnIiwiaXNOaWwiLCJ2ZXJzaW9ucyIsInZlcnNpb25JdGVtIiwiY29tcGFyZSIsImVyciIsInVuZGVmaW5lZCIsInBhcnNlQWRkcmVzcyIsInVybEFkZHJlc3MiLCJ1cmxQYXR0ZXJuIiwiZXhlYyIsInByb3RvIiwiREVGQVVMVF9QUk9UT0NPTCIsImhvc3QiLCJERUZBVUxUX0RPTUFJTiIsInBvcnQiLCJERUZBVUxUX1BPUlQiLCJwYXRoIiwic2VtdmVyU29ydCIsImxpc3RWZXJzaW9ucyIsImZpbHRlciIsIngiLCJsb2dnZXIiLCJ3YXJuIiwidmVyIiwic29ydCIsImNvbXBhcmVMb29zZSIsIm1hcCIsIlN0cmluZyIsIm5vcm1hbGl6ZURpc3RUYWdzIiwic29ydGVkIiwibGF0ZXN0IiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInBvcCIsImlzQXJyYXkiLCJpc1N0cmluZyIsInBhcnNlSW50ZXJ2YWxUYWJsZSIsIm1zIiwicyIsIm0iLCJoIiwiZCIsInciLCJNIiwieSIsInBhcnNlSW50ZXJ2YWwiLCJpbnRlcnZhbCIsInJlc3VsdCIsImxhc3Rfc3VmZml4IiwiSW5maW5pdHkiLCJzcGxpdCIsImZvckVhY2giLCJtYXRjaCIsIkVycm9yIiwiTnVtYmVyIiwiRXJyb3JDb2RlIiwicGFyc2VDb25maWdGaWxlIiwiY29uZmlnUGF0aCIsInRlc3QiLCJZQU1MIiwibG9hZCIsImZzIiwicmVhZEZpbGVTeW5jIiwicmVxdWlyZSIsImUiLCJjb2RlIiwibWVzc2FnZSIsIkFQUF9FUlJPUiIsIkNPTkZJR19OT1RfVkFMSUQiLCJmb2xkZXJFeGlzdHMiLCJzdGF0Iiwic3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsImZpbGVFeGlzdHMiLCJpc0ZpbGUiLCJzb3J0QnlOYW1lIiwicGFja2FnZXMiLCJvcmRlckFzY2VuZGluZyIsInNsaWNlIiwiYSIsImIiLCJjb21wYXJhdG9yTmFtZXMiLCJuYW1lIiwidG9Mb3dlckNhc2UiLCJhZGRTY29wZSIsInNjb3BlIiwicGFja2FnZU5hbWUiLCJkZWxldGVQcm9wZXJ0aWVzIiwicHJvcGVydGllc1RvRGVsZXRlIiwib2JqZWN0SXRlbSIsInByb3BlcnR5IiwiYWRkR3JhdmF0YXJTdXBwb3J0IiwicGtnSW5mbyIsIm9ubGluZSIsInBrZ0luZm9Db3B5IiwiYXV0aG9yIiwiZ2V0IiwiY29udHJpYnV0b3JzIiwibm9ybWFsaXplQ29udHJpYnV0b3JzIiwibWFpbnRhaW5lcnMiLCJlbWFpbCIsImF2YXRhciIsImdlbmVyYXRlR3JhdmF0YXJVcmwiLCJHRU5FUklDX0FWQVRBUiIsImlzRW1wdHkiLCJjb250cmlidXRvciIsIm1haW50YWluZXIiLCJwYXJzZVJlYWRtZSIsInJlYWRtZSIsImluZm8iLCJmb3JtYXRBdXRob3IiLCJhdXRob3JEZXRhaWxzIiwiREVGQVVMVF9VU0VSIiwidXJsIiwicGFkIiwic3RyIiwibWF4IiwicmVwZWF0IiwibWFzayIsImNoYXJOdW0iLCJzdWJzdHIiLCJlbmNvZGVTY29wZWRVcmkiLCJyZXBsYWNlIiwiaGFzRGlmZk9uZUtleSIsImlzVmVyc2lvblZhbGlkIiwicGFja2FnZU1ldGEiLCJwYWNrYWdlVmVyc2lvbiIsImhhc1ZlcnNpb24iLCJoYXNNYXRjaFZlcnNpb24iLCJpbmNsdWRlcyIsImlzUmVsYXRlZFRvRGVwcmVjYXRpb24iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWxpZGF0ZVVSTCIsInB1YmxpY1VybCIsInBhcnNlZCIsIlVSTCIsInByb3RvY29sIiwiaXNIb3N0Iiwib3B0aW9ucyIsInZhbGlkYXRvciIsImlzVVJMIiwicmVxdWlyZV9ob3N0IiwiYWxsb3dfdHJhaWxpbmdfZG90IiwicmVxdWlyZV92YWxpZF9wcm90b2NvbCIsInJlcXVpcmVfcG9ydCIsInJlcXVpcmVfdGxkIiwiaGFzTG9naW4iLCJjb25maWciLCJ3ZWIiLCJsb2dpbiJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IGJ1aWxkRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBZQU1MIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJ3ZhbGlkYXRvcic7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5pbXBvcnQgeyBlcnJvclV0aWxzLCB2YWxpZGF0aW9VdGlscyB9IGZyb20gJ0B2ZXJkYWNjaW8vY29yZSc7XG5pbXBvcnQgeyBTdHJpbmdWYWx1ZSB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgQXV0aG9yLCBDb25maWcsIFBhY2thZ2UsIFZlcnNpb24gfSBmcm9tICdAdmVyZGFjY2lvL3R5cGVzJztcbmltcG9ydCB7XG4gIEdFTkVSSUNfQVZBVEFSLFxuICBidWlsZFRva2VuIGFzIGJ1aWxkVG9rZW5VdGlsLFxuICBnZW5lcmF0ZUdyYXZhdGFyVXJsLFxuICBub3JtYWxpemVDb250cmlidXRvcnMsXG59IGZyb20gJ0B2ZXJkYWNjaW8vdXRpbHMnO1xuXG5pbXBvcnQgeyBBdXRob3JBdmF0YXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBBUFBfRVJST1IsXG4gIERFRkFVTFRfRE9NQUlOLFxuICBERUZBVUxUX1BPUlQsXG4gIERFRkFVTFRfUFJPVE9DT0wsXG4gIERFRkFVTFRfVVNFUixcbiAgRElTVF9UQUdTLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5cbmNvbnN0IHtcbiAgZ2V0QmFkRGF0YSxcbiAgZ2V0QmFkUmVxdWVzdCxcbiAgZ2V0Q29kZSxcbiAgZ2V0Q29uZmxpY3QsXG4gIGdldEZvcmJpZGRlbixcbiAgZ2V0SW50ZXJuYWxFcnJvcixcbiAgZ2V0Tm90Rm91bmQsXG4gIGdldFNlcnZpY2VVbmF2YWlsYWJsZSxcbiAgZ2V0VW5hdXRob3JpemVkLFxufSA9IGVycm9yVXRpbHM7XG5jb25zdCBkZWJ1ZyA9IGJ1aWxkRGVidWcoJ3ZlcmRhY2NpbycpO1xuY29uc3QgdmFsaWRQcm90b2NvbHMgPSBbJ2h0dHBzJywgJ2h0dHAnXTtcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UGF5bG9hZFRvQmFzZTY0KHBheWxvYWQ6IHN0cmluZyk6IEJ1ZmZlciB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShwYXlsb2FkLCAnYmFzZTY0Jyk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIE9iamVjdFxuICogQHBhcmFtIHsqfSBvYmogdGhlIGVsZW1lbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9IHZhbGlkYXRpb1V0aWxzLmlzT2JqZWN0O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIG5vdCB1c2VkIHVuIHY2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdE9yQXJyYXkob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIF8uaXNPYmplY3Qob2JqKSAmJiBfLmlzTnVsbChvYmopID09PSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhZ1ZlcnNpb24oZGF0YTogUGFja2FnZSwgdmVyc2lvbjogc3RyaW5nLCB0YWc6IFN0cmluZ1ZhbHVlKTogYm9vbGVhbiB7XG4gIGlmICh0YWcgJiYgZGF0YVtESVNUX1RBR1NdW3RhZ10gIT09IHZlcnNpb24gJiYgc2VtdmVyLnBhcnNlKHZlcnNpb24sIHRydWUpKSB7XG4gICAgLy8gdmFsaWQgdmVyc2lvbiAtIHN0b3JlXG4gICAgZGF0YVtESVNUX1RBR1NdW3RhZ10gPSB2ZXJzaW9uO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXRzIHZlcnNpb24gZnJvbSBhIHBhY2thZ2Ugb2JqZWN0IHRha2luZyBpbnRvIGFjY291bnQgc2VtdmVyIHdlaXJkbmVzcy5cbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG9mIGEgcGFja2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVyc2lvbihwa2c6IFBhY2thZ2UsIHZlcnNpb246IGFueSk6IFZlcnNpb24gfCB2b2lkIHtcbiAgLy8gdGhpcyBjb25kaXRpb24gbXVzdCBhbGxvdyBjYXN0XG4gIGlmIChfLmlzTmlsKHBrZy52ZXJzaW9uc1t2ZXJzaW9uXSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHBrZy52ZXJzaW9uc1t2ZXJzaW9uXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmVyc2lvbiA9IHNlbXZlci5wYXJzZSh2ZXJzaW9uLCB0cnVlKTtcbiAgICBmb3IgKGNvbnN0IHZlcnNpb25JdGVtIGluIHBrZy52ZXJzaW9ucykge1xuICAgICAgaWYgKHZlcnNpb24uY29tcGFyZShzZW12ZXIucGFyc2UodmVyc2lvbkl0ZW0sIHRydWUpKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGtnLnZlcnNpb25zW3ZlcnNpb25JdGVtXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBpbnRlcm5ldCBhZGRyZXNzXG4gKiBBbGxvdzpcbiAtIGh0dHBzOmxvY2FsaG9zdDoxMjM0ICAgICAgICAtIHByb3RvY29sICsgaG9zdCArIHBvcnRcbiAtIGxvY2FsaG9zdDoxMjM0ICAgICAgICAgICAgICAtIGhvc3QgKyBwb3J0XG4gLSAxMjM0ICAgICAgICAgICAgICAgICAgICAgICAgLSBwb3J0XG4gLSBodHRwOjoxMjM0ICAgICAgICAgICAgICAgICAgLSBwcm90b2NvbCArIHBvcnRcbiAtIGh0dHBzOi8vbG9jYWxob3N0OjQ0My8gICAgICAtIGZ1bGwgdXJsICsgaHR0cHNcbiAtIGh0dHA6Ly9bOjoxXTo0NDMvICAgICAgICAgICAtIGlwdjZcbiAtIHVuaXg6L3RtcC9odHRwLnNvY2sgICAgICAgICAtIHVuaXggc29ja2V0c1xuIC0gaHR0cHM6Ly91bml4Oi90bXAvaHR0cC5zb2NrIC0gdW5peCBzb2NrZXRzIChodHRwcylcbiAqIEBwYXJhbSB7Kn0gdXJsQWRkcmVzcyB0aGUgaW50ZXJuZXQgYWRkcmVzcyBkZWZpbml0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R8TnVsbH0gbGl0ZXJhbCBvYmplY3QgdGhhdCByZXByZXNlbnQgdGhlIGFkZHJlc3MgcGFyc2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFkZHJlc3ModXJsQWRkcmVzczogYW55KTogYW55IHtcbiAgLy9cbiAgLy8gVE9ETzogcmVmYWN0b3IgaXQgdG8gc29tZXRoaW5nIG1vcmUgcmVhc29uYWJsZT9cbiAgLy9cbiAgLy8gICAgICAgIHByb3RvY29sIDogIC8vICAgICAgKCAgaG9zdCAgKXwoICAgIGlwdjYgICAgICk6ICBwb3J0ICAvXG4gIGxldCB1cmxQYXR0ZXJuID0gL14oKGh0dHBzPyk6KFxcL1xcLyk/KT8oKChbXlxcLzpdKil8XFxbKFteXFxbXFxdXSspXFxdKTopPyhcXGQrKVxcLz8kLy5leGVjKHVybEFkZHJlc3MpO1xuXG4gIGlmICh1cmxQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RvOiB1cmxQYXR0ZXJuWzJdIHx8IERFRkFVTFRfUFJPVE9DT0wsXG4gICAgICBob3N0OiB1cmxQYXR0ZXJuWzZdIHx8IHVybFBhdHRlcm5bN10gfHwgREVGQVVMVF9ET01BSU4sXG4gICAgICBwb3J0OiB1cmxQYXR0ZXJuWzhdIHx8IERFRkFVTFRfUE9SVCxcbiAgICB9O1xuICB9XG5cbiAgdXJsUGF0dGVybiA9IC9eKChodHRwcz8pOihcXC9cXC8pPyk/dW5peDooLiopJC8uZXhlYyh1cmxBZGRyZXNzKTtcblxuICBpZiAodXJsUGF0dGVybikge1xuICAgIHJldHVybiB7XG4gICAgICBwcm90bzogdXJsUGF0dGVyblsyXSB8fCBERUZBVUxUX1BST1RPQ09MLFxuICAgICAgcGF0aDogdXJsUGF0dGVybls0XSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZmlsdGVycyBvdXQgYmFkIHNlbXZlciB2ZXJzaW9ucyBhbmQgc29ydHMgdGhlIGFycmF5LlxuICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VtdmVyU29ydChsaXN0VmVyc2lvbnM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIGxpc3RWZXJzaW9uc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXNlbXZlci5wYXJzZSh4LCB0cnVlKSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKHsgdmVyOiB4IH0sICdpZ25vcmluZyBiYWQgdmVyc2lvbiBAe3Zlcn0nKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KVxuICAgICAgLy8gRklYTUU6IGl0IHNlZW1zIHRoZSBAdHlwZXMvc2VtdmVyIGRvIG5vdCBoYW5kbGUgYSBsZWdpdGltYXRlIG1ldGhvZCBuYW1lZCAnY29tcGFyZUxvb3NlJ1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLnNvcnQoc2VtdmVyLmNvbXBhcmVMb29zZSlcbiAgICAgIC5tYXAoU3RyaW5nKVxuICApO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYXJyYXlzIG9mIHRhZ3MuXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZURpc3RUYWdzKHBrZzogUGFja2FnZSk6IHZvaWQge1xuICBsZXQgc29ydGVkO1xuICBpZiAoIXBrZ1tESVNUX1RBR1NdLmxhdGVzdCkge1xuICAgIC8vIG92ZXJ3cml0ZSBsYXRlc3Qgd2l0aCBoaWdoZXN0IGtub3duIHZlcnNpb24gYmFzZWQgb24gc2VtdmVyIHNvcnRcbiAgICBzb3J0ZWQgPSBzZW12ZXJTb3J0KE9iamVjdC5rZXlzKHBrZy52ZXJzaW9ucykpO1xuICAgIGlmIChzb3J0ZWQgJiYgc29ydGVkLmxlbmd0aCkge1xuICAgICAgcGtnW0RJU1RfVEFHU10ubGF0ZXN0ID0gc29ydGVkLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgdGFnIGluIHBrZ1tESVNUX1RBR1NdKSB7XG4gICAgaWYgKF8uaXNBcnJheShwa2dbRElTVF9UQUdTXVt0YWddKSkge1xuICAgICAgaWYgKHBrZ1tESVNUX1RBR1NdW3RhZ10ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHNvcnQgYXJyYXlcbiAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgY2xlYXJseSB3cm9uZywgd2UgbmVlZCB0byByZXNlYXJjaCB3aHkgdGhpcyBpcyBsaWtlIHRoaXMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc29ydGVkID0gc2VtdmVyU29ydChwa2dbRElTVF9UQUdTXVt0YWddKTtcbiAgICAgICAgaWYgKHNvcnRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyB1c2UgaGlnaGVzdCB2ZXJzaW9uIGJhc2VkIG9uIHNlbXZlciBzb3J0XG4gICAgICAgICAgcGtnW0RJU1RfVEFHU11bdGFnXSA9IHNvcnRlZC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHBrZ1tESVNUX1RBR1NdW3RhZ107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHBrZ1tESVNUX1RBR1NdW3RhZ10pKSB7XG4gICAgICBpZiAoIXNlbXZlci5wYXJzZShwa2dbRElTVF9UQUdTXVt0YWddLCB0cnVlKSkge1xuICAgICAgICAvLyBpZiB0aGUgdmVyc2lvbiBpcyBpbnZhbGlkLCBkZWxldGUgdGhlIGRpc3QtdGFnIGVudHJ5XG4gICAgICAgIGRlbGV0ZSBwa2dbRElTVF9UQUdTXVt0YWddO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwYXJzZUludGVydmFsVGFibGUgPSB7XG4gICcnOiAxMDAwLFxuICBtczogMSxcbiAgczogMTAwMCxcbiAgbTogNjAgKiAxMDAwLFxuICBoOiA2MCAqIDYwICogMTAwMCxcbiAgZDogODY0MDAwMDAsXG4gIHc6IDcgKiA4NjQwMDAwMCxcbiAgTTogMzAgKiA4NjQwMDAwMCxcbiAgeTogMzY1ICogODY0MDAwMDAsXG59O1xuXG4vKipcbiAqIFBhcnNlIGFuIGludGVybmFsIHN0cmluZyB0byBudW1iZXJcbiAqIEBwYXJhbSB7Kn0gaW50ZXJ2YWxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZXJ2YWwoaW50ZXJ2YWw6IGFueSk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGludGVydmFsICogMTAwMDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gMDtcbiAgbGV0IGxhc3Rfc3VmZml4ID0gSW5maW5pdHk7XG4gIGludGVydmFsLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoeCk6IHZvaWQge1xuICAgIGlmICgheCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtID0geC5tYXRjaCgvXigoMHxbMS05XVswLTldKikoXFwuWzAtOV0rKT8pKG1zfHN8bXxofGR8d3xNfHl8KSQvKTtcbiAgICBpZiAoXG4gICAgICAhbSB8fFxuICAgICAgcGFyc2VJbnRlcnZhbFRhYmxlW21bNF1dID49IGxhc3Rfc3VmZml4IHx8XG4gICAgICAobVs0XSA9PT0gJycgJiYgbGFzdF9zdWZmaXggIT09IEluZmluaXR5KVxuICAgICkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2ludmFsaWQgaW50ZXJ2YWw6ICcgKyBpbnRlcnZhbCk7XG4gICAgfVxuICAgIGxhc3Rfc3VmZml4ID0gcGFyc2VJbnRlcnZhbFRhYmxlW21bNF1dO1xuICAgIHJlc3VsdCArPSBOdW1iZXIobVsxXSkgKiBwYXJzZUludGVydmFsVGFibGVbbVs0XV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY29uc3QgRXJyb3JDb2RlID0ge1xuICBnZXRDb25mbGljdCxcbiAgZ2V0QmFkRGF0YSxcbiAgZ2V0QmFkUmVxdWVzdCxcbiAgZ2V0SW50ZXJuYWxFcnJvcixcbiAgZ2V0VW5hdXRob3JpemVkLFxuICBnZXRGb3JiaWRkZW4sXG4gIGdldFNlcnZpY2VVbmF2YWlsYWJsZSxcbiAgZ2V0Tm90Rm91bmQsXG4gIGdldENvZGUsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb25maWdGaWxlKGNvbmZpZ1BhdGg6IHN0cmluZyk6IGFueSB7XG4gIHRyeSB7XG4gICAgaWYgKC9cXC55YT9tbCQvaS50ZXN0KGNvbmZpZ1BhdGgpKSB7XG4gICAgICByZXR1cm4gWUFNTC5sb2FkKGZzLnJlYWRGaWxlU3luYyhjb25maWdQYXRoLCAndXRmLTgnKSk7XG4gICAgfVxuICAgIGRlYnVnKCd5YW1sIHBhcnNlZCcpO1xuICAgIHJldHVybiByZXF1aXJlKGNvbmZpZ1BhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ3lhbWwgcGFyc2UgZmFpbGVkJyk7XG4gICAgaWYgKGUuY29kZSAhPT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICBlLm1lc3NhZ2UgPSBBUFBfRVJST1IuQ09ORklHX05PVF9WQUxJRDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBwYXRoIGFscmVhZHkgZXhpc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvbGRlckV4aXN0cyhwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMocGF0aCk7XG4gICAgcmV0dXJuIHN0YXQuaXNEaXJlY3RvcnkoKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGZpbGUgYWxyZWFkeSBleGlzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsZUV4aXN0cyhwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMocGF0aCk7XG4gICAgcmV0dXJuIHN0YXQuaXNGaWxlKCk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCeU5hbWUocGFja2FnZXM6IGFueVtdLCBvcmRlckFzY2VuZGluZzogYm9vbGVhbiB8IHZvaWQgPSB0cnVlKTogc3RyaW5nW10ge1xuICByZXR1cm4gcGFja2FnZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKTogbnVtYmVyIHtcbiAgICBjb25zdCBjb21wYXJhdG9yTmFtZXMgPSBhLm5hbWUudG9Mb3dlckNhc2UoKSA8IGIubmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgcmV0dXJuIG9yZGVyQXNjZW5kaW5nID8gKGNvbXBhcmF0b3JOYW1lcyA/IC0xIDogMSkgOiBjb21wYXJhdG9yTmFtZXMgPyAxIDogLTE7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkU2NvcGUoc2NvcGU6IHN0cmluZywgcGFja2FnZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgQCR7c2NvcGV9LyR7cGFja2FnZU5hbWV9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnRpZXMocHJvcGVydGllc1RvRGVsZXRlOiBzdHJpbmdbXSwgb2JqZWN0SXRlbTogYW55KTogYW55IHtcbiAgXy5mb3JFYWNoKHByb3BlcnRpZXNUb0RlbGV0ZSwgKHByb3BlcnR5KTogYW55ID0+IHtcbiAgICBkZWxldGUgb2JqZWN0SXRlbVtwcm9wZXJ0eV07XG4gIH0pO1xuXG4gIHJldHVybiBvYmplY3RJdGVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkR3JhdmF0YXJTdXBwb3J0KHBrZ0luZm86IFBhY2thZ2UsIG9ubGluZSA9IHRydWUpOiBBdXRob3JBdmF0YXIge1xuICBjb25zdCBwa2dJbmZvQ29weSA9IHsgLi4ucGtnSW5mbyB9IGFzIGFueTtcbiAgY29uc3QgYXV0aG9yOiBhbnkgPSBfLmdldChwa2dJbmZvLCAnbGF0ZXN0LmF1dGhvcicsIG51bGwpIGFzIGFueTtcbiAgY29uc3QgY29udHJpYnV0b3JzOiBBdXRob3JBdmF0YXJbXSA9IG5vcm1hbGl6ZUNvbnRyaWJ1dG9ycyhcbiAgICBfLmdldChwa2dJbmZvLCAnbGF0ZXN0LmNvbnRyaWJ1dG9ycycsIFtdKVxuICApO1xuICBjb25zdCBtYWludGFpbmVycyA9IF8uZ2V0KHBrZ0luZm8sICdsYXRlc3QubWFpbnRhaW5lcnMnLCBbXSk7XG5cbiAgLy8gZm9yIGF1dGhvci5cbiAgaWYgKGF1dGhvciAmJiBfLmlzT2JqZWN0KGF1dGhvcikpIHtcbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhdXRob3IgYXMgQXV0aG9yO1xuICAgIHBrZ0luZm9Db3B5LmxhdGVzdC5hdXRob3IuYXZhdGFyID0gZ2VuZXJhdGVHcmF2YXRhclVybChlbWFpbCwgb25saW5lKTtcbiAgfVxuXG4gIGlmIChhdXRob3IgJiYgXy5pc1N0cmluZyhhdXRob3IpKSB7XG4gICAgcGtnSW5mb0NvcHkubGF0ZXN0LmF1dGhvciA9IHtcbiAgICAgIGF2YXRhcjogR0VORVJJQ19BVkFUQVIsXG4gICAgICBlbWFpbDogJycsXG4gICAgICBhdXRob3IsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGZvciBjb250cmlidXRvcnNcbiAgaWYgKF8uaXNFbXB0eShjb250cmlidXRvcnMpID09PSBmYWxzZSkge1xuICAgIHBrZ0luZm9Db3B5LmxhdGVzdC5jb250cmlidXRvcnMgPSBjb250cmlidXRvcnMubWFwKChjb250cmlidXRvcik6IEF1dGhvckF2YXRhciA9PiB7XG4gICAgICBpZiAoaXNPYmplY3QoY29udHJpYnV0b3IpKSB7XG4gICAgICAgIGNvbnRyaWJ1dG9yLmF2YXRhciA9IGdlbmVyYXRlR3JhdmF0YXJVcmwoY29udHJpYnV0b3IuZW1haWwsIG9ubGluZSk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoY29udHJpYnV0b3IpKSB7XG4gICAgICAgIGNvbnRyaWJ1dG9yID0ge1xuICAgICAgICAgIGF2YXRhcjogR0VORVJJQ19BVkFUQVIsXG4gICAgICAgICAgZW1haWw6IGNvbnRyaWJ1dG9yLFxuICAgICAgICAgIG5hbWU6IGNvbnRyaWJ1dG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udHJpYnV0b3I7XG4gICAgfSk7XG4gIH1cblxuICAvLyBmb3IgbWFpbnRhaW5lcnNcbiAgaWYgKF8uaXNFbXB0eShtYWludGFpbmVycykgPT09IGZhbHNlKSB7XG4gICAgcGtnSW5mb0NvcHkubGF0ZXN0Lm1haW50YWluZXJzID0gbWFpbnRhaW5lcnMubWFwKChtYWludGFpbmVyKTogdm9pZCA9PiB7XG4gICAgICBtYWludGFpbmVyLmF2YXRhciA9IGdlbmVyYXRlR3JhdmF0YXJVcmwobWFpbnRhaW5lci5lbWFpbCwgb25saW5lKTtcbiAgICAgIHJldHVybiBtYWludGFpbmVyO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBrZ0luZm9Db3B5O1xufVxuXG4vKipcbiAqIHBhcnNlIHBhY2thZ2UgcmVhZG1lIC0gbWFya2Rvd24vYXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrYWdlTmFtZSBuYW1lIG9mIHBhY2thZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFkbWUgcGFja2FnZSByZWFkbWVcblxuICogQHJldHVybiB7U3RyaW5nfSBjb252ZXJ0ZWQgaHRtbCB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWFkbWUocGFja2FnZU5hbWU6IHN0cmluZywgcmVhZG1lOiBzdHJpbmcpOiBzdHJpbmcgfCB2b2lkIHtcbiAgaWYgKF8uaXNFbXB0eShyZWFkbWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFkbWU7XG4gIH1cblxuICAvLyBsb2dzIHJlYWRtZSBub3QgZm91bmQgZXJyb3JcbiAgbG9nZ2VyLmluZm8oeyBwYWNrYWdlTmFtZSB9LCAnQHtwYWNrYWdlTmFtZX06IE5vIHJlYWRtZSBmb3VuZCcpO1xuXG4gIHJldHVybiAnRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kISc7XG59XG5cbmV4cG9ydCB0eXBlIEF1dGhvckZvcm1hdCA9IEF1dGhvciB8IHN0cmluZyB8IG51bGwgfCBvYmplY3QgfCB2b2lkO1xuXG4vKipcbiAqIEZvcm1hdHMgYXV0aG9yIGZpZWxkIGZvciB3ZWJ1aS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9maWxlcy9wYWNrYWdlLmpzb24jYXV0aG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R8dW5kZWZpbmVkfSBhdXRob3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEF1dGhvcihhdXRob3I6IEF1dGhvckZvcm1hdCk6IGFueSB7XG4gIGxldCBhdXRob3JEZXRhaWxzID0ge1xuICAgIG5hbWU6IERFRkFVTFRfVVNFUixcbiAgICBlbWFpbDogJycsXG4gICAgdXJsOiAnJyxcbiAgfTtcblxuICBpZiAoXy5pc05pbChhdXRob3IpKSB7XG4gICAgcmV0dXJuIGF1dGhvckRldGFpbHM7XG4gIH1cblxuICBpZiAoXy5pc1N0cmluZyhhdXRob3IpKSB7XG4gICAgYXV0aG9yRGV0YWlscyA9IHtcbiAgICAgIC4uLmF1dGhvckRldGFpbHMsXG4gICAgICBuYW1lOiBhdXRob3IgYXMgc3RyaW5nLFxuICAgIH07XG4gIH1cblxuICBpZiAoXy5pc09iamVjdChhdXRob3IpKSB7XG4gICAgYXV0aG9yRGV0YWlscyA9IHtcbiAgICAgIC4uLmF1dGhvckRldGFpbHMsXG4gICAgICAuLi4oYXV0aG9yIGFzIEF1dGhvciksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBhdXRob3JEZXRhaWxzO1xufVxuXG4vKipcbiAqIEFwcGx5IHdoaXRlc3BhY2VzIGJhc2VkIG9uIHRoZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gc3RyIHRoZSBsb2cgbWVzc2FnZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKHN0ciwgbWF4KTogc3RyaW5nIHtcbiAgaWYgKHN0ci5sZW5ndGggPCBtYXgpIHtcbiAgICByZXR1cm4gc3RyICsgJyAnLnJlcGVhdChtYXggLSBzdHIubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIHJldHVybiBhIG1hc3F1ZXJhZGUgc3RyaW5nIHdpdGggaXRzIGZpcnN0IGFuZCBsYXN0IHtjaGFyTnVtfSBhbmQgdGhyZWUgZG90cyBpbiBiZXR3ZWVuLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJOdW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXNrKHN0cjogc3RyaW5nLCBjaGFyTnVtID0gMyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtzdHIuc3Vic3RyKDAsIGNoYXJOdW0pfS4uLiR7c3RyLnN1YnN0cigtY2hhck51bSl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVNjb3BlZFVyaShwYWNrYWdlTmFtZSk6IHN0cmluZyB7XG4gIHJldHVybiBwYWNrYWdlTmFtZS5yZXBsYWNlKC9cXC8vZywgJyUyZicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRGlmZk9uZUtleSh2ZXJzaW9ucyk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LmtleXModmVyc2lvbnMpLmxlbmd0aCAhPT0gMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvblZhbGlkKHBhY2thZ2VNZXRhLCBwYWNrYWdlVmVyc2lvbik6IGJvb2xlYW4ge1xuICBjb25zdCBoYXNWZXJzaW9uID0gdHlwZW9mIHBhY2thZ2VWZXJzaW9uICE9PSAndW5kZWZpbmVkJztcbiAgaWYgKCFoYXNWZXJzaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgaGFzTWF0Y2hWZXJzaW9uID0gT2JqZWN0LmtleXMocGFja2FnZU1ldGEudmVyc2lvbnMpLmluY2x1ZGVzKHBhY2thZ2VWZXJzaW9uKTtcbiAgcmV0dXJuIGhhc01hdGNoVmVyc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVsYXRlZFRvRGVwcmVjYXRpb24ocGtnSW5mbzogUGFja2FnZSk6IGJvb2xlYW4ge1xuICBjb25zdCB7IHZlcnNpb25zIH0gPSBwa2dJbmZvO1xuICBmb3IgKGNvbnN0IHZlcnNpb24gaW4gdmVyc2lvbnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZlcnNpb25zW3ZlcnNpb25dLCAnZGVwcmVjYXRlZCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVUkwocHVibGljVXJsOiBzdHJpbmcgfCB2b2lkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IFVSTChwdWJsaWNVcmwgYXMgc3RyaW5nKTtcbiAgICBpZiAoIXZhbGlkUHJvdG9jb2xzLmluY2x1ZGVzKHBhcnNlZC5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2ludmFsaWQgcHJvdG9jb2wnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRPRE86IGFkZCBlcnJvciBsb2dnZXIgaGVyZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIb3N0KHVybDogc3RyaW5nID0gJycsIG9wdGlvbnMgPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsaWRhdG9yLmlzVVJMKHVybCwge1xuICAgIHJlcXVpcmVfaG9zdDogdHJ1ZSxcbiAgICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlLFxuICAgIHJlcXVpcmVfdmFsaWRfcHJvdG9jb2w6IGZhbHNlLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXF1aXJlX3BvcnQ6IGZhbHNlLFxuICAgIHJlcXVpcmVfdGxkOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0xvZ2luKGNvbmZpZzogQ29uZmlnKSB7XG4gIC8vIEZJWE1FOiB0eXBlcyBhcmUgbm90IHlldCBvbiB0aGUgbGlicmFyeSB2ZXJkYWNjaW8vbW9ub3JlcG9cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gXy5pc05pbChjb25maWc/LndlYj8ubG9naW4pIHx8IGNvbmZpZz8ud2ViPy5sb2dpbiA9PT0gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgYnVpbGRUb2tlblV0aWwgYXMgYnVpbGRUb2tlbiB9O1xu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